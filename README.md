# fun-execution

This project demonstates a complete execution pipeline for a functional language.

We compile `.fun` source programs (examples in `fun/`) into byte-code. The compiler is structured as a series of transformations through intermediate representations, culminating in byte-code. The compiler is written in Haskell. The main byte-code execution engine in written in C.

We can generate standalone byte-code (to be linked with the execution engine) using the batch compiler. Here we display the generated byte-code in the terminal:

    $ stack run batch -- fun/nfib.fun >(cat)


Alternatively, we can test & develop our program using a console which runs the full compiler pipeline, but provides the byte-code interpreter in Haskell.

    $ stack run console -- fun/nfib.fun


We can use the console for limited interactive development. If we dont name a program on the command line, then it it defaults to a `.history` file.

    $ stack run console

#### Representations and Transformations

These are the intermediate representations used in the compiler:

    1, Ast -- Abstract syntax tree from the parser.
    2, Anf -- A-normal form: Control is made explicit.
    3, Clo -- Closure-converted: Environment is made explicit.
    4, Lin -- Linear. Code-sequences & literals. Essentially byte-code.

This is the  compiler pipeline:

    Parse:       -> Ast
    Normalize:      Ast
    Flatten:        Ast -> Anf
    Convert:               Anf -> Clo
    Linearize:                    Clo -> Lin
    Export:                              Lin ->

The parser generates the `Ast` representation.  The final representation `Lin` can be exported as byte-code in C-format. The transformation stages `Flatten`, `Convert` and `Linearize` move between the different representions: `Ast -> Anf -> Clo -> Lin`. The `Normalise` transformation is unusual having `Ast` as both source and target of the transformation.


The normalization phase implements _normalization by evaluation_. The phase can be skipped using the `-nn` (no-normalization) flag of the console or batch front-ends. The quality of the generated byte-code is much reduced:

    $ stack run batch -- -nn fun/nfib.fun >(cat)


The intermediate representions of the compiler can be viewed using the `-view` flag of the front-ends.

    $ stack run batch -- -view fun/nfib.fun /dev/null

### Examples

There are a bunch of examples to play with in the `fun/` subdirectory. For example, `fun/pythagorian.fun` which computes pythagorian triples smaller than 20. Or `fun/nthPrime.fun` which computes (using a very slow algorithm) the nth prime number, where _n_ is given by the first command-line argument.

These can be run by `console` or `batch` as described above, viewing the intermediate representations using `-view`. In addition, the compiled C-code can be conveniently generated, compiled & linked via targets in the Makefile. This could all be much slicker, but it suffices.

    $ stack run batch -- -view fun/pythagorian.fun /dev/null

    $ make _build/pythagorian
    $ _build/pythagorian

    $ make _build/nthPrime
    $ _build/nthPrime 100


The pythagorian example shows how we can do list-processing, despite there being no real `data` types provided by the `fun` language. We simply represent lists using _scott encoding_. As a bonus, these will be optimized/inlined during the _normalization_ phase, just like any other function.

### Compiler

Haskell code for the compiler is in `src/`. A good place to start is the various intermediate representations (`Rep_*.hs`). And then see how the various transformations (`Trans_*.hs) are sequenced in `Pipeline.hs`

### Run time

The code for the runtime framework is in `bc/engine.c`. It contains the byte code interpreter, builtins, and hooks for interoperability with native-code (under development). All allocation is in the `heap` (one big statically allocated C-array). There is currently no garbage collector written.

The subdirectory `perf/` contains code & Makefile to explore runtime performance. For example to see how many _nfibs/second_ the compiled code runs at:

    $ cd perf
    $ make nfib

#### Todo:

- More details on the intermediate representations and transformation phases.
- Discuss the byte-code engine. Representation choices.
- Performance.

#### Future:

- Clean up and unify the front-ends, as: `func`
- Track source location information through pipeline.
- Generate C-code (via macros) instead of byte-code.
- Garbage collector.
