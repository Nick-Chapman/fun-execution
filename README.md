# fun-execution

This project demonstates a complete execution pipeline for a functional language.

We compile `.fun` source programs (examples in `fun/`) into byte-code. The compiler is structured as a series of transformations through intermediate representations, culminating in byte-code. The compiler is written in Haskell. The main byte-code execution engine in written in C.

We can generate standalone byte-code (to be linked with the execution engine) using the batch compiler. Here we display the generated byte-code in the terminal:

    $ stack run batch -- fun/nfib.fun >(cat)


Alternatively, we can test & develop our program using a console which runs the full compiler pipeline, but provides the byte-code interpreter in Haskell.

    $ stack run console -- fun/nfib.fun


We can use the console for limited interactive development. If we dont name a program on the command line, then it it defaults to a `.history` file.

    $ stack run console

#### Representations and Transformations

These are the intermediate representations used in the compiler:

    1, Ast -- Abstract syntax tree from the parser.
    2, Anf -- A-normal form: Control is made explicit.
    3, Clo -- Closure-converted: Environment is made explicit.
    4, Lin -- Linear. Code-sequences & literals. Essentially byte-code.

This is the  compiler pipeline:

    Parse:       -> Ast
    Normalize:      Ast
    Flatten:        Ast -> Anf
    Convert:               Anf -> Clo
    Linearize:                    Clo -> Lin
    Export:                              Lin ->

The parser generates the `Ast` representation.  The final representation `Lin` can be exported as byte-code in C-format. The transformation stages `Flatten`, `Convert` and `Linearize` move between the different representions: `Ast -> Anf -> Clo -> Lin`. The `Normalise` transformation is unusual having `Ast` as both source and target of the transformation.


The normalization phase implements _normalization by evaluation_. The phase can be skipped using the `-nn` (no-normalization) flag of the console or batch front-ends. The quality of the generated byte-code is much reduced:

    $ stack run batch -- -nn fun/nfib.fun >(cat)


The intermediate representions of the compiler can be viewed using the `-view` flag of the front-ends.

    $ stack run batch -- -view fun/nfib.fun /dev/null

#### Todo:

- Explain how to link and run the generated byte-code.
- More details on the intermediate representations and transformation phases.
- Discuss the byte-code engine. Representation choices.
- Performance.

#### Future:

- Clean up and unify the front-ends, as: `func`
- Track source location information through pipeline.
- Generate C-code (via macros) instead of byte-code.
- Garbage collector.
